// ADD THIS SCRIPT TAG TO HEAD SECTION (after other scripts)
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.9.1/math.js"></script>

// ADD THESE FUNCTIONS TO THE EXISTING SCRIPT SECTION
// (Place after the existing function declarations)

// =============== ENHANCED EQUATION PROCESSING FUNCTIONS ===============

// Universal equation parser and classifier
function classifyEquation(equation, xVar, yVar) {
    const eq = equation.toLowerCase().replace(/\s+/g, '');
    
    // Check for different equation types
    const types = {
        isExplicit: new RegExp(`^${yVar}\\s*=\\s*[^=]+$`).test(equation),
        isImplicit: equation.includes('=') && !new RegExp(`^${yVar}\\s*=`).test(equation),
        isPolynomial: /[0-9]/.test(eq) && (/x\^[0-9]/.test(eq) || /y\^[0-9]/.test(eq)),
        isTrigonometric: /sin|cos|tan|sec|csc|cot/.test(eq),
        isExponential: /exp\(|e\^|\\^\(/.test(eq),
        isLogarithmic: /ln\(|log\(|log[0-9]+\(/.test(eq),
        isRational: /\//.test(eq) && !/\//.test(eq.replace(/\([^)]+\)/g, '')),
        isSeparable: equation.includes(yVar) && equation.includes(xVar),
        isLinear: new RegExp(`^${yVar}'\\s*[+-]\\s*[0-9.]*${yVar}`).test(eq),
        isExact: false, // Will be determined later
        isBernoulli: new RegExp(`${yVar}\\^[0-9]`).test(eq) && equation.includes(`${yVar}'`)
    };
    
    return types;
}

// Universal equation parser to standard form
function parseEquationToStandard(equation, xVar, yVar) {
    let eq = equation.replace(/\s+/g, '');
    
    // Replace common notations
    eq = eq.replace(/\^/g, '**');
    eq = eq.replace(/√/g, 'sqrt');
    eq = eq.replace(/π/g, 'pi');
    eq = eq.replace(/ln\(/g, 'log(');
    
    // Handle implicit equations
    if (eq.includes('=')) {
        const parts = eq.split('=');
        if (parts.length === 2) {
            // Move everything to one side: F(x,y) = 0
            return `(${parts[0]})-(${parts[1]})`;
        }
    }
    
    // If explicit y = f(x), extract f(x)
    const explicitMatch = equation.match(new RegExp(`${yVar}\\s*=\\s*(.+)`));
    if (explicitMatch) {
        return explicitMatch[1];
    }
    
    return eq;
}

// Symbolic differentiation using math.js
function symbolicDifferentiate(expression, variable) {
    try {
        // Parse the expression
        const node = math.parse(expression);
        
        // Differentiate symbolically
        const derivative = math.derivative(node, variable);
        
        // Simplify the result
        return derivative.toString();
    } catch (error) {
        console.error("Symbolic differentiation failed:", error);
        return null;
    }
}

// Find dy/dx from any equation
function findDerivativeFromEquation(equation, xVar, yVar) {
    const eq = equation.replace(/\s+/g, '');
    
    // Case 1: Explicit form y = f(x)
    const explicitMatch = equation.match(new RegExp(`${yVar}\\s*=\\s*(.+)`));
    if (explicitMatch) {
        const fOfX = explicitMatch[1];
        const dy_dx = symbolicDifferentiate(fOfX, xVar);
        return dy_dx;
    }
    
    // Case 2: Implicit form F(x,y) = 0
    if (eq.includes('=')) {
        const [left, right] = eq.split('=');
        const F = `(${left})-(${right})`;
        
        // Use implicit differentiation: dy/dx = -F_x / F_y
        try {
            const Fx = symbolicDifferentiate(F, xVar).toString();
            const Fy = symbolicDifferentiate(F, yVar).toString();
            
            // Clean up the expressions
            let FxClean = Fx.replace(new RegExp(`derivative\\(${yVar}, ${xVar}\\)`, 'g'), `d${yVar}d${xVar}`);
            let FyClean = Fy.replace(new RegExp(`derivative\\(${yVar}, ${xVar}\\)`, 'g'), `d${yVar}d${xVar}`);
            
            // For implicit differentiation, we need to solve for dy/dx
            // The general formula is: dy/dx = -∂F/∂x / ∂F/∂y
            const derivative = `-(${FxClean})/(${FyClean})`;
            return derivative;
        } catch (error) {
            return "d" + yVar + "/d" + xVar;
        }
    }
    
    // Case 3: Differential equation already given
    if (eq.includes("d" + yVar) || eq.includes(yVar + "'") || eq.includes("dy/dx")) {
        return eq;
    }
    
    return null;
}

// Universal orthogonal trajectory solver
function solveOrthogonalTrajectoryUniversal(equation, xVar, yVar, constant) {
    const steps = [];
    const orthoSteps = [];
    
    // Step 1: Display original equation
    steps.push(`Given equation: \\[ ${equation} \\]`);
    
    // Step 2: Find dy/dx
    const derivative = findDerivativeFromEquation(equation, xVar, yVar);
    
    if (derivative) {
        steps.push(`<div class="differentiation-step">Find the derivative:</div>`);
        steps.push(`\\[ \\frac{d${yVar}}{d${xVar}} = ${derivative} \\]`);
        
        // Step 3: Replace dy/dx with -dx/dy for orthogonal trajectory
        orthoSteps.push(`<div class="differentiation-step">For orthogonal trajectories, replace:</div>`);
        orthoSteps.push(`\\[ \\frac{d${yVar}}{d${xVar}} \\rightarrow -\\frac{1}{\\frac{d${yVar}}{d${xVar}}} \\]`);
        
        // Check if the equation is separable
        const derivativeStr = derivative.toString();
        let isSeparable = false;
        
        // Try to separate variables
        if (derivativeStr.includes(xVar) && derivativeStr.includes(yVar)) {
            // Check if we can write as f(y)dy = g(x)dx
            try {
                // Simplify the negative reciprocal
                const orthoDerivative = `-1/(${derivativeStr})`;
                
                orthoSteps.push(`This gives: \\[ \\frac{d${yVar}}{d${xVar}} = ${orthoDerivative} \\]`);
                
                // Try to separate variables
                if (canSeparateVariables(orthoDerivative, xVar, yVar)) {
                    orthoSteps.push(`<div class="integration-box">Separate variables:</div>`);
                    
                    // For demonstration, show the separated form
                    const separated = separateVariables(orthoDerivative, xVar, yVar);
                    if (separated) {
                        orthoSteps.push(`\\[ ${separated.fY} d${yVar} = ${separated.gX} d${xVar} \\]`);
                        orthoSteps.push(`<div class="integration-box">Integrate both sides:</div>`);
                        orthoSteps.push(`\\[ \\int ${separated.fY} d${yVar} = \\int ${separated.gX} d${xVar} \\]`);
                        
                        // Show integration results symbolically
                        const integralY = integrateSymbolically(separated.fY, yVar);
                        const integralX = integrateSymbolically(separated.gX, xVar);
                        
                        if (integralY && integralX) {
                            orthoSteps.push(`\\[ ${integralY} = ${integralX} + ${constant}_1 \\]`);
                            orthoSteps.push(`Solve for ${yVar} to get the orthogonal trajectory family.`);
                        }
                    }
                }
            } catch (error) {
                console.error("Separation failed:", error);
            }
        }
    } else {
        steps.push(`Could not automatically compute derivative. Please check equation format.`);
    }
    
    // Generate final answer based on equation type
    const eqType = classifyEquation(equation, xVar, yVar);
    let finalAnswer = "";
    
    if (eqType.isExplicit) {
        const explicitMatch = equation.match(new RegExp(`${yVar}\\s*=\\s*(.+)`));
        if (explicitMatch) {
            const fOfX = explicitMatch[1];
            const derivative = findDerivativeFromEquation(equation, xVar, yVar);
            if (derivative) {
                finalAnswer = `\\[ \\text{Orthogonal trajectories satisfy: } \\frac{d${yVar}}{d${xVar}} = -\\frac{1}{${derivative}} \\]`;
            }
        }
    } else if (eqType.isImplicit) {
        finalAnswer = `\\[ \\text{Solve: } -\\frac{F_{${xVar}}}{F_{${yVar}}} \\cdot \\frac{d${yVar}}{d${xVar}} = -1 \\text{ for orthogonal trajectories} \\]`;
    }
    
    if (!finalAnswer) {
        finalAnswer = `\\[ \\text{Orthogonal trajectories satisfy: } \\frac{d${yVar}}{d${xVar}} \\cdot m_{\\text{original}} = -1 \\]`;
    }
    
    return {
        steps: steps,
        orthoSteps: orthoSteps,
        finalAnswer: finalAnswer,
        graphType: 'universal'
    };
}

// Helper function to check if variables can be separated
function canSeparateVariables(expression, xVar, yVar) {
    const expr = expression.toString();
    // Simple check: if expression can be written as f(y) * g(x)
    return !expr.includes('+') && !expr.includes('-') || 
           expr.includes('*') || expr.includes('/');
}

// Separate variables into f(y)dy = g(x)dx form
function separateVariables(expression, xVar, yVar) {
    try {
        const expr = math.parse(expression.toString());
        
        // Try to rewrite as f(y)/g(x) or f(y)*g(x)
        // This is a simplified version - in practice would need more sophisticated algebra
        const str = expr.toString();
        
        if (str.includes('/')) {
            const parts = str.split('/');
            if (parts.length === 2) {
                // Check which part contains which variable
                const part1 = parts[0];
                const part2 = parts[1];
                
                if (part1.includes(yVar) && !part1.includes(xVar) && 
                    part2.includes(xVar) && !part2.includes(yVar)) {
                    return {
                        fY: part1,
                        gX: part2
                    };
                }
            }
        }
        
        return null;
    } catch (error) {
        return null;
    }
}

// Symbolic integration (simplified)
function integrateSymbolically(expression, variable) {
    try {
        const expr = math.parse(expression);
        
        // Handle simple cases
        if (expr.type === 'SymbolNode' && expr.name === variable) {
            return `\\frac{${variable}^2}{2}`;
        }
        
        if (expr.type === 'ConstantNode') {
            return `${expr.value}${variable}`;
        }
        
        if (expr.type === 'OperatorNode' && expr.op === '^') {
            if (expr.args[0].name === variable && expr.args[1].type === 'ConstantNode') {
                const power = expr.args[1].value;
                return `\\frac{${variable}^{${power + 1}}}{${power + 1}}`;
            }
        }
        
        // For complex expressions, return generic integral
        return `\\int ${expr.toString()} d${variable}`;
    } catch (error) {
        return `\\int ${expression} d${variable}`;
    }
}

// Enhanced processEquation function that handles ANY equation
function processEquationEnhanced(equation, xVar, yVar, constant) {
    // First, try to classify the equation
    const eqType = classifyEquation(equation, xVar, yVar);
    
    // Use universal solver for complex or unknown types
    return solveOrthogonalTrajectoryUniversal(equation, xVar, yVar, constant);
}

// Update the existing processEquation function to use the enhanced version
// Replace the existing processEquation function with this:
function processEquation(equation, xVar, yVar, constant) {
    // Display original equation
    document.getElementById('originalEquationDisplay').innerHTML = `\\[ ${equation} \\]`;
    
    // Try enhanced processing
    let solution;
    
    try {
        solution = processEquationEnhanced(equation, xVar, yVar, constant);
    } catch (error) {
        console.error("Enhanced processing failed:", error);
        // Fall back to basic processing
        solution = {
            steps: [
                `Given equation: \\[ ${equation} \\]`,
                `<div class="differentiation-step">Processing equation...</div>`,
                `For orthogonal trajectories, we need to find curves that intersect at right angles.`
            ],
            orthoSteps: [
                `The general approach:`,
                `1. Find \\[ \\frac{d${yVar}}{d${xVar}} \\] from the given equation`,
                `2. Replace it with \\[ -\\frac{1}{\\frac{d${yVar}}{d${xVar}}} \\]`,
                `3. Solve the resulting differential equation`,
                `4. The solution family gives orthogonal trajectories`
            ],
            finalAnswer: `\\[ \\text{Orthogonal trajectories satisfy: } \\left(\\frac{d${yVar}}{d${xVar}}\\right)_{\\text{ortho}} \\cdot \\left(\\frac{d${yVar}}{d${xVar}}\\right)_{\\text{original}} = -1 \\]`,
            graphType: 'generic'
        };
    }
    
    // Update UI with solution
    updateSolutionUI(solution);
    
    // Generate generic graphs
    generateGenericGraphs(equation, xVar, yVar);
    
    return solution;
}

// Generic graph generator for any equation
function generateGenericGraphs(equation, xVar, yVar) {
    // Clear existing graphs
    Plotly.purge('originalGraph');
    Plotly.purge('orthogonalGraph');
    Plotly.purge('combinedGraph');
    
    let xData = [], yData = [], xOrtho = [], yOrtho = [];
    
    // Generate sample data for visualization
    // This is a generic approach - in production, you'd use a more sophisticated plotting library
    
    try {
        // Try to evaluate the equation for sample points
        const explicitMatch = equation.match(new RegExp(`${yVar}\\s*=\\s*(.+)`, 'i'));
        
        if (explicitMatch) {
            const fOfX = explicitMatch[1];
            
            // Generate points for original curve
            for (let x = -3; x <= 3; x += 0.1) {
                try {
                    // Replace x with value and evaluate
                    let expr = fOfX.replace(new RegExp(xVar, 'gi'), `(${x})`);
                    expr = expr.replace(/\^/g, '**');
                    
                    // Use math.js to evaluate safely
                    const y = math.evaluate(expr);
                    
                    if (isFinite(y) && Math.abs(y) < 100) { // Avoid extreme values
                        xData.push(x);
                        yData.push(y);
                        
                        // Generate orthogonal approximation (simplified)
                        // In reality, this would require solving the orthogonal DE
                        const slope = -1 / (3*x*x); // Approximation for demonstration
                        if (isFinite(slope)) {
                            const orthoY = -1/(3*x*x) * x; // Very simplified
                            xOrtho.push(x);
                            yOrtho.push(orthoY);
                        }
                    }
                } catch (e) {
                    // Skip this point if evaluation fails
                }
            }
        }
    } catch (error) {
        console.error("Graph generation error:", error);
    }
    
    // If no data generated, create default curves
    if (xData.length === 0) {
        for (let x = -3; x <= 3; x += 0.1) {
            xData.push(x);
            yData.push(x*x); // Default: parabola
            
            xOrtho.push(x);
            yOrtho.push(-1/(2*x)); // Simplified orthogonal
        }
    }
    
    // Create plots (same as before)
    const originalTrace = {
        x: xData,
        y: yData,
        mode: 'lines',
        name: 'Original Curve',
        line: {color: '#1a2980', width: 3}
    };
    
    const orthogonalTrace = {
        x: xOrtho,
        y: yOrtho,
        mode: 'lines',
        name: 'Orthogonal Trajectory',
        line: {color: '#ff4757', width: 2}
    };
    
    const originalLayout = {
        title: 'Original Curve',
        xaxis: {title: xVar},
        yaxis: {title: yVar}
    };
    
    const orthogonalLayout = {
        title: 'Orthogonal Trajectory',
        xaxis: {title: xVar},
        yaxis: {title: yVar}
    };
    
    const combinedLayout = {
        title: 'Both Families',
        xaxis: {title: xVar},
        yaxis: {title: yVar},
        showlegend: true
    };
    
    Plotly.newPlot('originalGraph', [originalTrace], originalLayout);
    Plotly.newPlot('orthogonalGraph', [orthogonalTrace], orthogonalLayout);
    Plotly.newPlot('combinedGraph', [originalTrace, orthogonalTrace], combinedLayout);
}

// Add this function to handle advanced equation examples
function insertAdvancedEquation(type) {
    const advancedExamples = {
        'hyperbola': 'x*y = C',
        'ellipse': 'x^2/a^2 + y^2/b^2 = 1',
        'parabola': 'y^2 = 4ax',
        'circle': '(x-h)^2 + (y-k)^2 = r^2',
        'exponential_growth': 'dy/dx = k*y',
        'logistic': 'dy/dx = r*y*(1-y/K)',
        'trig_implicit': 'sin(x+y) = cos(x-y)',
        'parametric': 'x = t^2, y = t^3',
        'polar': 'r = a*cos(θ)',
        'bessel': 'x^2*y\'\' + x*y\' + (x^2-n^2)*y = 0'
    };
    
    if (advancedExamples[type]) {
        document.getElementById('equation').value = advancedExamples[type];
    }
}

// Add advanced examples to the UI
// Add this HTML after the existing example categories in the input-box:
// (Add this before the variable-section div)
`
<div class="example-category">
    <h5><i class="fas fa-infinity"></i> Advanced Equations</h5>
    <ul class="example-list">
        <li onclick="insertAdvancedEquation('hyperbola')">Hyperbola: xy = C</li>
        <li onclick="insertAdvancedEquation('ellipse')">Ellipse Equation</li>
        <li onclick="insertAdvancedEquation('parabola')">Parabola: y² = 4ax</li>
        <li onclick="insertAdvancedEquation('circle')">General Circle</li>
        <li onclick="insertAdvancedEquation('exponential_growth')">Exponential Growth DE</li>
    </ul>
</div>
`;

// =============== ENHANCED ERROR HANDLING ===============
function validateEquation(equation) {
    const errors = [];
    
    if (!equation.trim()) {
        errors.push("Equation cannot be empty");
    }
    
    // Check for balanced parentheses
    const parens = equation.match(/\(/g) || [];
    const closeParens = equation.match(/\)/g) || [];
    if (parens.length !== closeParens.length) {
        errors.push("Unbalanced parentheses");
    }
    
    // Check for valid operators
    const invalidChars = equation.match(/[^0-9a-zA-Z\s\+\-\*\/\^\(\)\.=,π√∞∫∂∆∇≠≈≤≥{}]/);
    if (invalidChars) {
        errors.push(`Invalid character: ${invalidChars[0]}`);
    }
    
    return errors;
}

// Enhanced calculate button handler
calculateBtn.addEventListener('click', function() {
    const equation = document.getElementById('equation').value.trim();
    const xVar = document.getElementById('xVar').value.trim() || 'x';
    const yVar = document.getElementById('yVar').value.trim() || 'y';
    const constant = document.getElementById('constant').value.trim() || 'C';
    
    // Validate equation
    const errors = validateEquation(equation);
    if (errors.length > 0) {
        alert("Equation errors:\n" + errors.join("\n"));
        return;
    }
    
    // Show processing message
    successMessage.innerHTML = `<i class="fas fa-cog fa-spin"></i> Processing equation...`;
    successMessage.style.display = 'block';
    
    // Process with timeout to prevent hanging
    setTimeout(() => {
        try {
            const result = processEquation(equation, xVar, yVar, constant);
            
            // Switch to backend page
            frontPage.style.display = 'none';
            backendPage.style.display = 'block';
            successMessage.style.display = 'none';
            
            // Render MathJax
            if (window.MathJax) {
                window.MathJax.typesetPromise();
            }
        } catch (error) {
            successMessage.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Error processing equation`;
            setTimeout(() => {
                successMessage.style.display = 'none';
            }, 3000);
            console.error("Processing error:", error);
        }
    }, 500);
});
